# ==============================================================================
# R Sidecar: Functional Data Analysis (FDA) for Topological Validation
# ==============================================================================
# Objective: Validate the "Roughness" of the OCaml Manifold using B-Splines.
# Input:  state.json (Generated by OCaml Kernel)
# Output: diagnostic_manifold.png (Topological mismatch visualization)

suppressPackageStartupMessages({
  library(jsonlite)
  library(fda)
  library(ggplot2)
})

# [God Math]: The B-Spline Basis Function
# Mathematical Def: B_i,k(t) = (t - t_i) / (t_{i+k-1} - t_i) * B_i,k-1(t) + ...
# Intuition: We decompose the jagged price path into a sum of smooth, bell-shaped curves.
# This filters out the "High Frequency Noise" (Brownian Motion) and leaves only the "Signal" (Drift + Jump).

args <- commandArgs(trailingOnly = TRUE)
input_file <- if (length(args) > 0) args[1] else "state.json"

if (!file.exists(input_file)) {
  stop("Input file 'state.json' not found.")
}

data <- fromJSON(input_file)
raw_path <- data$raw_path
n_points <- length(raw_path)
time_grid <- seq(0, 1, length.out = n_points)

# 1. Create B-Spline Basis
# [God Math]: Knots and Order
# Rule of Thumb: n_basis = n_points + order - 2
# We use Order 4 (Cubic Splines) to ensure the 2nd derivative (Curvature) is continuous.
n_basis <- min(20, n_points - 2)
basis_obj <- create.bspline.basis(rangeval = c(0, 1), nbasis = n_basis, norder = 4)

# 2. Smooth the Data (Penalized Least Squares)
# [God Math]: The Roughness Penalty (lambda * Integral(D^2 f(t))^2 dt)
# We minimize: SSE + lambda * Roughness
# High Lambda = Smoother Curve (High Bias, Low Variance)
# Low Lambda = Jaggier Curve (Low Bias, High Variance)
# We choose lambda = 1e-4 to catch the "Macro Structure" without the "Micro Noise".
fd_obj <- smooth.basis(time_grid, raw_path, basis_obj, lambda = 1e-4)$fd

# 3. Calculate Functional Curvature (Roughness)
# [God Math]: The L2 Norm of the Second Derivative
# Roughness = Integral( (d^2/dt^2 f(t))^2 ) dt
# This scalar number represents the "Topological Energy" of the path.
# If Roughness is High but Price Change is Low -> "Market is Churning" (Gamma Trap).
roughness <- inprod(fd_obj, fd_obj, Lfd=2, Lfd=2)

# 4. Compare with OCaml Fisher Metric
ocaml_fisher <- data$manifold$fisher_distance
topological_mismatch <- abs(scale(roughness) - scale(ocaml_fisher))

# 5. Generate Diagnostic Plot
# Mapped Geometric Space vs. Functional Space
# [FIX]: Output directly to UI public folder so Vite can serve it.
outfile <- "ui/public/diagnostic_manifold.png"
png(outfile, width = 800, height = 400)
par(mfrow=c(1,2), bg="#050510", fg="#e0e0e0", col.axis="#888", col.lab="#888", col.main="#e0e0e0")

# Plot 1: The Smoothing Fit
plotfit.fd(raw_path, time_grid, fd_obj, main="B-Spline Smoothing (FDA)", 
           xlab="Time", ylab="Price", col="cyan", lwd=2)
grid()

# Plot 2: Topological Consistency
# If points lie on the diagonal, OCaml Geometry matches R Functional Analysis.
# Off-diagonal = "Topological Mismatch" (The signal is fake).
barplot(c(OCaml_Fisher=ocaml_fisher, R_Roughness=log(roughness)), 
        main="Geometry vs. Topology", col=c("#00e5ff", "#ff0055"), 
        border=NA, las=1)
grid()

dev.off()

cat(sprintf("R Analysis Complete. Roughness Penalty: %.4f\n", roughness))
